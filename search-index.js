var searchIndex = JSON.parse('{\
"leetcode":{"doc":"","t":"F","n":["add"],"q":[[0,"leetcode"]],"d":[""],"i":[0],"f":[[[1,1],1]],"c":[],"p":[[15,"usize"]]},\
"max_passengers":{"doc":"","t":"DLLLLLLLLL","n":["Solution","borrow","borrow_mut","explore_path","from","into","max_passengers","try_from","try_into","type_id"],"q":[[0,"max_passengers"],[10,"alloc::vec"],[11,"core::result"],[12,"core::any"]],"d":["A taxi can take multiple passengers to the railway station …","","","The algorithm follows a Depth-First Search (DFS) approach …","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Arguments","","",""],"i":[0,8,8,8,8,8,8,8,8,8],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[[[2,[[2,[1]]]],3,3,[2,[[2,[1]]]],[2,[[2,[1]]]],[2,[[2,[4]]]]],5],[-1,-1,[]],[-1,-2,[],[]],[[[2,[[2,[1]]]]],1],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,7,[]]],"c":[],"p":[[15,"i32"],[3,"Vec",10],[15,"usize"],[15,"bool"],[15,"tuple"],[4,"Result",11],[3,"TypeId",12],[3,"Solution",0]]},\
"max_sliding_window":{"doc":"","t":"DLLLLLLLL","n":["Solution","borrow","borrow_mut","from","into","max_sliding_window","try_from","try_into","type_id"],"q":[[0,"max_sliding_window"],[9,"alloc::vec"],[10,"core::result"],[11,"core::any"]],"d":["The Solution struct represents a solution to the “…","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Finds the maximum value in each sliding window of size <code>k</code> …","","",""],"i":[0,5,5,5,5,5,5,5,5],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-1,[]],[-1,-2,[],[]],[[[2,[1]],1],[[2,[1]]]],[-1,[[3,[-2]]],[],[]],[-1,[[3,[-2]]],[],[]],[-1,4,[]]],"c":[],"p":[[15,"i32"],[3,"Vec",9],[4,"Result",10],[3,"TypeId",11],[3,"Solution",0]]},\
"remove_linked_list_elememt":{"doc":"","t":"DDLLLLLLLLLLLLLMLLLLLLLLM","n":["ListNode","Solution","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","eq","equivalent","fmt","from","from","into","into","next","remove_elements","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","val"],"q":[[0,"remove_linked_list_elememt"],[25,"core::fmt"],[26,"core::fmt"],[27,"core::option"],[28,"core::result"],[29,"core::any"]],"d":["Definition of a singly-linked list node. pub next: …","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Next node in the linked list.","Implementation of removing elements","","","","","","","","Value stored in the node."],"i":[0,0,11,1,11,1,1,1,1,1,1,11,1,11,1,1,11,1,11,1,11,1,11,1,1],"f":[0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[[-1,-2],2,[],[]],[[1,1],3],[[-1,-2],3,[],[]],[[1,4],5],[-1,-1,[]],[-1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],0,[[[7,[[6,[1]]]],8],[[7,[[6,[1]]]]]],[-1,-2,[],[]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,10,[]],[-1,10,[]],0],"c":[],"p":[[3,"ListNode",0],[15,"tuple"],[15,"bool"],[3,"Formatter",25],[6,"Result",25],[3,"Box",26],[4,"Option",27],[15,"i32"],[4,"Result",28],[3,"TypeId",29],[3,"Solution",0]]},\
"sum_of_left_leaves":{"doc":"","t":"DDLLLLLLLLMLMLLLLLLLM","n":["Solution","TreeNode","borrow","borrow","borrow_mut","borrow_mut","from","from","into","into","left","new","right","sum_of_left_leaves","try_from","try_from","try_into","try_into","type_id","type_id","val"],"q":[[0,"sum_of_left_leaves"],[21,"core::cell"],[22,"alloc::rc"],[23,"core::option"],[24,"core::ops::arith"],[25,"core::ops::arith"],[26,"core::marker"],[27,"core::result"],[28,"core::any"]],"d":["Solution struct","Defines a generic struct named TreeNode with a type …","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Define the left child of the current node It is an Option …","Creates a new tree node with the given value.","","Implemention the sum_of_left_leaves method with recursive …","","","","","","","<code>T</code> Holds the value of the node"],"i":[0,0,1,11,1,11,1,11,1,11,1,1,1,11,1,11,1,11,1,11,1],"f":[0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-1,[]],[-1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],0,[-1,[[1,[-1]]],[]],0,[[[4,[[3,[[2,[[1,[-1]]]]]]]]],-1,[5,6,7,8]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,10,[]],[-1,10,[]],0],"c":[],"p":[[3,"TreeNode",0],[3,"RefCell",21],[3,"Rc",22],[4,"Option",23],[8,"Add",24],[8,"AddAssign",24],[8,"Default",25],[8,"Copy",26],[4,"Result",27],[3,"TypeId",28],[3,"Solution",0]]},\
"three_sum":{"doc":"","t":"DLLLLLLLL","n":["Solution","borrow","borrow_mut","from","into","three_sum","try_from","try_into","type_id"],"q":[[0,"three_sum"],[9,"alloc::vec"],[10,"core::result"],[11,"core::any"]],"d":["","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","",""],"i":[0,5,5,5,5,5,5,5,5],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-1,[]],[-1,-2,[],[]],[[[2,[1]]],[[2,[[2,[1]]]]]],[-1,[[3,[-2]]],[],[]],[-1,[[3,[-2]]],[],[]],[-1,4,[]]],"c":[],"p":[[15,"i32"],[3,"Vec",9],[4,"Result",10],[3,"TypeId",11],[3,"Solution",0]]},\
"top_k_frequent":{"doc":"","t":"DLLLLLLLL","n":["Solution","borrow","borrow_mut","from","into","top_k_frequent","try_from","try_into","type_id"],"q":[[0,"top_k_frequent"],[9,"alloc::vec"],[10,"core::result"],[11,"core::any"]],"d":["The Solution struct represents a solution to the “…","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Finds the top k frequent elements in an array.","","",""],"i":[0,5,5,5,5,5,5,5,5],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-1,[]],[-1,-2,[],[]],[[[2,[1]],1],[[2,[1]]]],[-1,[[3,[-2]]],[],[]],[-1,[[3,[-2]]],[],[]],[-1,4,[]]],"c":[],"p":[[15,"i32"],[3,"Vec",9],[4,"Result",10],[3,"TypeId",11],[3,"Solution",0]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
